from utc.src.graph import RoadNetwork, Route
from utc.src.routing.base.controlled_vehicle import ControlledVehicle, Vehicle, ControlledVehicle, Segment
from utc.src.routing.control.vehicle_stats import VehicleStats, AssigmentStats
from utc.src.routing.control.vehicle_queue import VehicleQueue
from utc.src.simulator.simulation import Simulation, traci
from typing import Optional, List, Set, Tuple, Dict
from copy import deepcopy


class Scheduler:
    """
    Class scheduling vehicles from running simulation for online routing.
    """
    def __init__(self, network: RoadNetwork, reserve: int):
        """
        :param network: the road network of running simulation
        """
        self.road_network: RoadNetwork = network
        self.queue: VehicleQueue = VehicleQueue()
        self.vehicle_stats: VehicleStats = VehicleStats()
        self.assigment_stats: Dict[str, AssigmentStats] = {"DUO": AssigmentStats(), "DSO": AssigmentStats()}
        self.reserve: int = reserve

    def step(self, simulation: Simulation) -> List[ControlledVehicle]:
        """
        :param simulation: the current running SUMO simulation
        :return: List of currently inserted vehicles (can be empty) to simulation
        """
        if not simulation.is_running():
            return []
        # Process vehicles which arrived this time step (i.e. left simulation)
        arrived, missed = self.queue.set_arrival(traci.simulation.getArrivedIDList())
        self.vehicle_stats.missed += missed
        # Process vehicles which just entered the network
        departed_vehicles: List[ControlledVehicle] = []
        for vehicle_id in traci.simulation.getDepartedIDList():
            self.insert_vehicle(vehicle_id)
            if vehicle_id in self.queue.vehicles:
                departed_vehicles.append(self.queue.vehicles[vehicle_id])
        return departed_vehicles

    # ------------------------------------------- Route assigment -------------------------------------------

    def assign_routes(
            self, vehicles: List[ControlledVehicle],
            routes: List[Optional[Route]], routing_type: str,
        ) -> int:
        """
        :param vehicles: to which new routes will be assigned
        :param routes: new routes to be assigned, must match the length of vehicles
        :param routing_type: which of DSO or DUO computed the routes
        :return: Total number of successfully assigned routes
        """
        successes: int = 0
        if len(vehicles) != len(routes):
            print("Error, number of vehicles and number of routes do not match!")
            return successes
        for vehicle, route in zip(vehicles, routes):
            successes += self.assign_route(vehicle, route, routing_type)
        if routing_type != "DUO":
            print(f"Successfully assigned {successes}/{len(vehicles)} routes generated by: {routing_type}")
        return successes

    def assign_route(self, vehicle: ControlledVehicle, route: Optional[Route], routing_type: str) -> bool:
        """
        :param vehicle: vehicle to which new route will be assigned
        :param route: new route to be assigned, can be None
        :param routing_type: which of DSO or DUO computed the route
        :return: True on success, False otherwise
        """
        self.assigment_stats[routing_type].total += 1
        # Cannot assign invalid route
        if route is None:
            return False
        # Cannot assign invalid vehicle
        elif vehicle.id not in self.queue.running:
            print(f"Vehicle {vehicle.id} has already left the simulation or been removed")
            return False
        elif not self.road_network.check_edge_sequence(route.get_edge_ids(False)):
            print(f"Error, vehicle: {vehicle.id} received invalid route, generated by: {routing_type}")
            print(f"Route: {route.get_edge_ids(False)}")
            quit()
            return False
        # Check route validity (starting and ending edges must match the current segment)
        segment: Segment = vehicle.route.get_current_segment()
        segment_edges: List[str] = vehicle.route.get_segment_edges(segment)
        original_start, original_end = segment_edges[0], segment_edges[-1]
        new_start, new_end = route.edge_list[0].id, route.edge_list[-1].id
        if original_start != new_start or original_end != new_end:
            print(f"Unable to assign route to vehicle: {vehicle.id}, mismatched starting and/or ending edges!")
            return False
        elif segment_edges == route.get_edge_ids(False):
            # print(f"Skipping assigment to vehicle: {vehicle.id}, new route is identical!")
            self.assigment_stats[routing_type].equal += 1
            self.assigment_stats[routing_type].successful += 1
            self.vehicle_stats.routed += 1
            return True
        # -------- Assign route dynamically using TraCI --------
        current_index: int = traci.vehicle.getRouteIndex(vehicle.id)
        if current_index > segment.indexes[0]:
            print(f"Vehicle: {vehicle.id} already passed the first segment edge, unable to assign route!")
            return False
        # TODO check if vehicle is on internal lane
        # Construct route
        changed_route: List[str] = deepcopy(vehicle.route.edges)
        changed_route[segment.indexes[0]:segment.indexes[1]] = route.get_edge_ids(False)
        assert(current_index < len(changed_route))
        try: # Assign route in simulation
            traci.vehicle.setRoute(vehicle.id, changed_route[current_index:])
        except traci.exceptions.TraCIException as e:
            print(f"Error when assigning route to vehicle: {vehicle.id}")
            return False
        # Adjust segments accordingly
        vehicle.route.update_current_segment(route.get_edge_ids(False), routing_type)
        self.vehicle_stats.routed += 1
        self.assigment_stats[routing_type].successful += 1
        return True

    # ------------------------------------------- ETA -------------------------------------------

    def update_travel_time(self) -> None:
        """
        Updates edge attributes based on current travel time, given by TraCI.

        :return: None
        """
        # print("Updating travel time on edges")
        for edge in self.road_network.edges.values():
            edge.attributes["travelTime"] = round(traci.edge.getTraveltime(edge.id), 3)
        return

    def schedule_vehicles(self, cut_off: float) -> List[ControlledVehicle]:
        """
        :param cut_off: maximal ETA time of vehicle, after which we skip them for scheduling
        :return: List of vehicles to be scheduled for routing (can be empty)
        """
        print(f"Computing eta for: {len(self.queue.running)} vehicles")
        scheduled: List[ControlledVehicle] = []  # List of vehicles scheduled for routing
        removed: List[str] = []
        # TODO skip over currently teleporting vehicles, as it may cause issues
        # traci.simulation.getStartingTeleportIDList()

        for vehicle_id in self.queue.running:
            vehicle: ControlledVehicle = self.queue.vehicles[vehicle_id]
            eta: float = self.compute_eta(vehicle)
            vehicle.route.get_current_segment().eta = eta
            assert(eta == -1 or eta >= 0)
            # No more routable segments for vehicle
            if eta == -1:
                # print(f"Removed vehicle: {vehicle.id}, route: {vehicle.route.edges}")
                # for segment in vehicle.route.segments:
                #     print(f"Segment: {vehicle.route.get_segment_edges(segment)}")
                #     print(f"Segment: {segment.routed_by}")
                # quit()
                removed.append(vehicle_id)
                continue
            # If vehicle ETA is within expected interval, consider it for scheduling
            elif eta <= cut_off:
                # print(f"Scheduling vehicle: '{vehicle.id}', eta: {route.eta}[s] to reserve")
                scheduled.append(vehicle)
            # else:  # eta > high -> keep vehicle in queue for next estimation step
            #    print(f"Vehicle: {vehicle_id} has too high ETA: {route.eta}, will be estimated next step")
        self.vehicle_stats.scheduled += len(scheduled)
        # Remove vehicle that we cannot route anymore
        for vehicle_id in removed:
            self.queue.running.remove(vehicle_id)
            self.queue.removed.add(vehicle_id)
        print(f"Scheduling {len(scheduled)} vehicles for routing")
        return scheduled

    def compute_eta(self, vehicle: ControlledVehicle) -> float:
        """
        :param vehicle: Vehicle for which eta is computed
        :return: Vehicles ETA to their current region, -1 if not possible to compute
        """
        assert(vehicle.id not in self.queue.arrived and vehicle.id not in self.queue.removed)
        current: int = traci.vehicle.getRouteIndex(vehicle.id)
        assert(current >= 0)  # Vehicle must have departed!
        assert(traci.vehicle.isRouteValid(vehicle.id))
        # Check if we missed segments for routing
        while current >= vehicle.route.get_current_segment().indexes[0]:
            self.vehicle_stats.missed += (vehicle.route.get_current_segment().routed_by == "")
            if vehicle.route.get_current_segment().routed_by != "":
                self.assigment_stats[vehicle.route.get_current_segment().routed_by].used += 1
            # Mark segment as missed
            vehicle.route.get_current_segment().eta = -1
            # No more segments for routing, vehicle passed all
            if not vehicle.switch_segment():
                return -1
        # Get edges from current position up to the next segment
        edges = vehicle.route.edges[current:vehicle.route.get_current_segment().indexes[0]]
        assert(len(edges) >= 1 and traci.vehicle.getRoute(vehicle.id)[current] == edges[0])
        # Compute eta, start by position on the current edge (lane)
        eta: float = self.road_network.get_edge(edges[0]).get_attribute("travelTime")
        lane_id: str = traci.vehicle.getLaneID(vehicle.id)
        # Skip calculation if we are on an internal lane (on junction)
        if lane_id and lane_id[0] != ":": # lane_id has to be checked to not be empty (possibly due to teleport etc.)
            fraction: float = 1.0 - (traci.vehicle.getLanePosition(vehicle.id) / traci.lane.getLength(lane_id))
            assert (0 <= fraction <= 1)
            eta *= fraction
        # Add travel time of the rest
        for edge in self.road_network.get_edges(edges[1:]):
            eta += edge.get_attribute("travelTime")
        return round(eta, 3)

    # ------------------------------------------- Vehicle arrival -------------------------------------------

    def insert_vehicle(self, vehicle_id: str) -> None:
        """
        Creates ControlledVehicle class and inserts it into the queue, also
        transforms the route into segments.

        :param vehicle_id: Identifier of vehicle which just entered simulation
        :return: None
        """
        self.vehicle_stats.departed += 1
        # Makes sure vehicle actually departed
        assert(traci.vehicle.getRouteIndex(vehicle_id) == 0)
        vehicle: ControlledVehicle = ControlledVehicle(
            Vehicle({"id": vehicle_id, "route": traci.vehicle.getRouteID(vehicle_id)}),
            list(traci.vehicle.getRoute(vehicle_id))
        )
        # TODO Create separate function for segmentation (also for already present route)
        # ----- Transform route into segments -----
        current_region, new_region = -1, -1  # "-1" stands for outside controlled region(s)
        start_i, end_i = 0, 0 # Edge indexes forming segment (sub-set of route edges)
        for edge in vehicle.route.edges:
            new_region = self.road_network.get_edge(edge).get_attribute("region")
            # New edge is in different region
            if current_region != new_region:
                if end_i != 0: # First edge is inside a region
                    vehicle.route.segments.append(Segment(start_i, end_i, current_region))
                current_region = new_region
                start_i = end_i
            end_i += 1
        # Final segment
        vehicle.route.segments.append(Segment(start_i, end_i, current_region))
        # Check correctness
        for segment in vehicle.route.segments:
            for edge in vehicle.route.get_segment_edges(segment):
                assert(self.road_network.get_edge(edge).get_attribute("region") == segment.region_id)
        for i in range(len(vehicle.route.segments) - 1):
            assert(vehicle.route.segments[i].region_id != vehicle.route.segments[i + 1].region_id)
        # TODO Based on configuration decide which segments we are actually interested in
        # Vehicle is considered for routing
        if len(vehicle.route.segments) != 0:
            self.vehicle_stats.considered += 1
            self.queue.add_vehicle(vehicle)
        return
